# Routing

## Terminology

**Tree**: Component tree with parent and children component.
**Subtree**: Part of tree, starting at a new root.
**Root**: First node in tree or subtree.
**Leaf**: Nodes which hae no children.
**URL Segment**: Part of the URL path delimited by slashes.
**URL Path**: Part of URL comes after domain.

## File Conventions

`layout`: Shared UI for a segment and it's children.
`page`: Unique UI ofa route that make routes publicly accessible.
`loading`: Loading UI for a segment and it's children.
`not-found`: Not found UI for a segment and its children.
`error`: Error UI for a segment and it's children.
`global-error`: Global Error UI.
`route`: Server-side API endpoint.
`template`: Specialized re-rendered Layout UI.
`default`: Fallback UI for Parallel Routes.

## Component Heirarchy

layout > template > error > loading > not-found > page/layout

```tsx
<Layout>
  <Template>
    <ErrorBoundary fallback={<Error />}>
      <Suspense fallback={<Loading />}>
        <ErrorBoundary fallback={<NotFound />}>
          <Page />
        </ErrorBoundary>
      </Suspense>
    </ErrorBoundary>
  </Template>
</Layout>
```

## Defining Routes

Folders are used to define routes.
A file `page.js` is used to make route segments publicly accesible.
Create a folder inside app directory and add page.jsx file inside it and export default the react component the folder name will be route for that component.

## Pages

- Page is UI that is unique to a route. you can define page by exporting it default from `page.js` file.

- To create a page for `/dashboard` route, create a folder called `dashboard` and `page.js` file inside of it.

- Pages are Server component by default.

```tsx
export default function Dashboard() {
  return (
    <>
      <h1 className="text-3xl font-bold underline">Dashboard</h1>
    </>
  );
}
```

## Layouts

- A layout is shared between multiple routes. layout preserves state, remain interactive, and do not re-render.
- Layouts can be nested
- You can define layout by exporting a React component from `layout.js` file and should accept `children` prop.
- Root layout is required at top level of app directory and must contain `html` and `body` tags.

```tsx
export const metadata = {
  title: "Dashboard",
  description: "Generated by Next.js, Description",
};

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <>
      <h2>Dashboard Layout</h2>
      {children}
    </>
  );
}
```

## Templates

When you use layout it renders only changed content and keep the state preserved.
`template.js` files remount and re-synced everything.

## Metadata

Metadata can be defined by exporting a metadata object or generateMetaData function in layout.js or page.js.

```tsx
import { Metadata } from "next";

export const metadata: Metadata = {
  title: "Next.js",
};
```

## Linking and Navigation

- Using the `<Link>` Component.
- Using the `useRouter` hook (Client component)
- Using the `redirect` function (Server component)
- Using the native History API

### Link Component

It is `<a>` tag with added functionality, it is recommenede way to navigate between routes.
You can use it from `next/link` and passing href prop.

```ts
import Link from "next/link";

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>;
}
```

### Checking Active Link

`usePathname()` to determine if link is active.

```tsx
"use client";

import { usePathname } from "next/navigation";
import Link from "next/link";

export function Links() {
  const pathname = usePathname();

  return (
    <nav>
      <ul>
        <li>
          <Link className={`link ${pathname === "/" ? "active" : ""}`} href="/">
            Home
          </Link>
        </li>
        <li>
          <Link
            className={`link ${pathname === "/about" ? "active" : ""}`}
            href="/about"
          >
            About
          </Link>
        </li>
      </ul>
    </nav>
  );
}
```

### Scrolling to an id

Default behavious of next is to scroll on top of new route or maintain the scroll position for backwards and forward navigations.

To scroll to a specific id add `#` after link.

```tsx
<Link href="/dashboard#settings">Settings</Link>
```

You can disable scroll restoration to Link or router.push() or router.replace()

```tsx
<Link href="/dashboard#settings" scroll={false}>
  Settings
</Link>
```

### useRouter() hook

It works in client side.

```tsx
"use client";

import { useRouter } from "next/navigation";

export default function Page() {
  const router = useRouter();

  return (
    <button type="button" onClick={() => router.push("/dashboard")}>
      Dashboard
    </button>
  );
}
```

### Redirect function

For Server component use `redirect` function instead.

```tsx
import { redirect } from "next/navigation";

async function fetchTeam(id: string) {
  const res = await fetch("https://...");
  if (!res.ok) return undefined;
  return res.json();
}

export default async function Profile({ params }: { params: { id: string } }) {
  const team = await fetchTeam(params.id);
  if (!team) {
    redirect("/login");
  }

  // ...
}
```

### Using the native History API

```tsx
"use client";

import { useSearchParams } from "next/navigation";

export default function SortProducts() {
  const searchParams = useSearchParams();

  function updateSorting(sortOrder: string) {
    const params = new URLSearchParams(searchParams.toString());
    params.set("sort", sortOrder);
    window.history.pushState(null, "", `?${params.toString()}`);
  }

  return (
    <>
      <button onClick={() => updateSorting("asc")}>Sort Ascending</button>
      <button onClick={() => updateSorting("desc")}>Sort Descending</button>
    </>
  );
}
```
